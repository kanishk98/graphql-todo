# Building a to-do web app with Hasura GraphQL engine and React.js

If you've been following the tech world lately, you'll know that GraphQL is a cool new query language for APIs. It's got a lot of features that should make it an easy choice for anyone working on an API: the importance given to <i>what</i> rather than how, the ability to batch multiple requests easily, and the freedom of the client to define whatever data it wants without having to create a new endpoint.

However, GraphQL is not without its problems. Some of them are:

  - Difficulty in setting up a GraphQL server
  - Defining resolvers for each query/mutation/subscription
  - Connecting resolvers to the underlying database

Speaking from personal experience, that last one is definitely a nightmare. 

That's where Hasura's GraphQL Engine comes in. It provides an easy kickstart to GraphQL development by giving the developer access to Heroku deployment (or Docker container) for a GraphQL server that can perform queries on a connected PostgreSQL database. All we have to do is define our good old table schema and the GraphQL SDL is generated for us (as are the templates for common queries, mutations, and subscriptions). If you know Prisma, Hasura's engine will sound familiar, with one key difference - Prisma is an additional database server that interfaces the GraphQL API with the underlying database. You still need to write resolvers that handle queries made to a GraphQL server you write, and you have to define your schema in GraphQL. Hasura allows your front-end to call the GraphQL API directly, just by using a relational Postgres schema you define. 

With that context, let's get started with building the app. 

> To follow along in this tutorial, you'll need a computer with git, React.js and the Chrome web browser. The latter is useful for debugging React applications.

## Initialising the project

I'll be using the `create-react-app` package to initialise a starter React.js project.

```sh
$ npm install -g create-react-app
$ create-react-app graphql-todo
```

Next, I'll log on to Hasura's [website](https://hasura.io) and create a new deployment on Heroku. You can either click [here](https://heroku.com/deploy?template=https://github.com/hasura/graphql-engine-heroku) or go to [this](https://docs.hasura.io/1.0/graphql/manual/getting-started/heroku-simple.html#deploy-to-heroku) page and click on the deploy button if the former doesn't work. 

This'll lead you to a setup of a basic project (once you've logged in to Heroku, of course). This is what it looks like for me:

![Heroku setup](https://raw.githubusercontent.com/kanishk98/graphql-todo/master/assets/heroku_setup.png)

Click on 'Deploy app' and we can move on to the next step. 

## Defining our schema

If you've followed the above steps correctly, you should see a dashboard similar to this image below (ignore the headers in the screenshot for now, we'll come to that later)

![Hasura API explorer](https://raw.githubuser.content.com/kanishk98/graphql-todo/master/assets/api_explorer_dashboard.png)

Let's click on Data in the top row and define our schema.

Our todo app will require users to log in via a Google account. Therefore, we should keep track of the users logging in and link each user account to their todos. 
Therefore, we'll make two tables - `todos` and `users`. 

Let's first considers `users`. 

We definitely need to store `userId` (this'll be the Firebase-generated UID of each user). This'll be our relation's primary key. We also need to store their email, their name, and their profile picture. Not that we're using any of those for this basic version of our todo app, but we might want to add this information to personalise the app a little in the future. 

Next, let's move to `todos`. We'll be storing all todos generated by all users of our app in this table. 
We'll identify todos based on their `todoId` (a v4 [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier), our primary key) and we'll also need to associate each todo with a user. For that, we need to store our `userId` here as well. 
We'll obviously need `text` (non-nullable, non-unique) of the todo item. 
We should probably save the `date` of creation of the todo as well, to help us sort them.
We'll store a boolean data item - `completed` - with each todo that's pretty much self-explanatory.

One additional constraint we should definitely add here is defining the `userId` as a foreign key that references the `users` table. So we can edit the `userId` field once we're done defining the schema, and add a relationship. 

> Relationships are an interesting Hasura implementation of SQL constraints in GraphQL; they do a great job of ensuring data consistency just like constraints defined in SQL. 

Our relationship should look something like this:

![Foreign key relationship](https://raw.githubusercontent.com/kanishk98/graphql-todo/master/assets/foreign_key.png)

We're all set on the schema side! Let's check out our database using GraphQL queries. 

## Testing database as admin using GraphQL

Navigate to the GraphiQL tab and write your first query. (actually, it's a mutation, but let's not be that pedantic).

This is what it looks like:

```
mutation {
  insert_users(objects: [{
    userId: "random_uid",
    name: "Kanishk Kakar",
    profilePic: "very_handsome_picture",
    email: "random@email.com"
  }]) {
    affected_rows
  }
}
```

On executing the above, you should see something like this:

![Mutation example](https://raw.githubusercontent.com/kanishk98/graphql-todo/master/assets/mutation.png)

Let's test this using a query on the same relation:

![Query example](https://raw.githubusercontent.com/kanishk98/graphql-todo/master/assets/query.png)

As you can see, we (the front-end) define *which* user we want by means of the `{where: { _eq: 'whatever' }}` and then specify that we only want the user's email, not his profile picture or name. That's how GraphQL speeds up API development. 

However, we're executing these queries as the admin right now. We need to give certain privileges to the end users of our app as well. 

## Role-based permissions

Hasura's engine makes IAM really easy for us. Under data, choose a table and then click on the Permissions tab. 
Enter a new role (I'll just call mine user, and set permissions for different operations there).

![Permissions](https://raw.githubusercontent.com/kanishk98/graphql-todo/master/assets/permissions.png)

This helps you define different user roles quickly, and was a personal delight for me. 

> This may seem trivial right now, but is actually an important step to understanding Hasura's engine: when we specify in the permissions policy that we require a condition (say, the equality condition on `userId`, as in my case) to be true for a database operation to complete, then our GraphQL API expects the `X-Hasura-User-Id` either as a header or as an object being returned from a webhook set up for authentication. I'll cover this down below. 

## Auth

### Front-end

To set up a login system, we'll use Firebase. Now, building the front-end system for that is trivial - we need to log on to the [Google Cloud Console](https://console.cloud.google.com), create a new project, and then make a new Firebase app on the [Firebase console](https://console.firebase.google.com). Now we'll run `$ npm install --save firebase` and follow the instructions for Node.js on [this Google-provided tutorial](). We should have a function that looks like this at the end:

```js
_onClickLogin = async () => {
    firebase
      .auth()
      .signInWithPopup(googleProvider)
      .then(async res => {
        const token = res.credential.accessToken;
        const user = res.user;
        console.log(res);
        await window.localStorage.setItem(Constants.LOGGED_IN, 'yes');
        await window.localStorage.setItem(Constants.USER_OBJECT, JSON.stringify(user));
        await window.localStorage.setItem(Constants.USER_TOKEN, JSON.stringify(token));
        this.setState({ loggedIn: true });
      })
      .catch(err => {
        console.log(err);
      });
  };
```

Awesome. This handles auth for the front-end web app, but we also need to handle auth for our GraphQL API. Again, Hasura smoothens things out for us.

### API

We'll use Firebase Cloud Functions to authenticate requests made to our GraphQL API. Why? Because we're already using Firebase, and I feel it's best to stick to as few platforms as possible as long as functionality stays the same. 

[Hasura Auth basics](https://docs.hasura.io/1.0/graphql/manual/auth/basics.html) explain the auth systems for the Engine very well, so I won't do that, but we shouldn't be sending key user information along with our API request headers.
To handle that constraint, we'll be using auth webhooks instead.

Before we do that, Hasura requires us to specify an access key on the API console. This is pretty easy. Head over to the API dashboard at Heroku's Settings, and click on Reveal Config Vars, as shown below:

![Config variables](https://rawgithubusercontent.com/kanishk98/graphql-todo/master/assets/config_vars.png)

Add a config variable `HASURA_GRAPHQL_ACCESS_KEY` and set it to whatever value seems best. You'll now also need this to log in to the API console. 

> Full disclosure: I properly understood how auth webhooks work only when I completed this app. Pretty cool stuff.

While [Hasura's sample](https://github.com/hasura/graphql-engine/tree/master/community/boilerplates/auth-webhooks/firebase-cloud-functions/index.js) on this topic is a great place to start, I think we can do a little bit better by skipping the need for a `config.js` file. Instead, as shown in the webhook handler I wrote [here](https://github.com/kanishk98/graphql-todo/blob/master/webhook/functions/index.js), we simply use the `functions.config()` method to initialise the app with our Firebase admin credentials. At this point, it's probably a wise idea to make a separate `webhook/` folder inside our main repository and continue working there.

To initialise the Firebase functions repository, we need to have the firebase CLI installed. Briefly, we need to do the following:

```sh
$ npm install -g firebase-tools
$ cd webhook
$ firebase init
```

Firebase will ask us a bunch of questions. Once that's done, all we have to do is hit `firebase deploy`.

Once we do that, we'll get a Firebase function URL in our terminal. Copy that, head over to the config variables section in our Heroku app dashboard, and add another config variable - `HASURA_GRAPHQL_AUTH_HOOK`. Set this to the URL of your Firebase function. (It should be something along the lines of `https://us-central1-whatever-app.cloudfunctions.net/yourwebhook`). This was required so that Hasura Engine where to request user information from when we make requests to it. 

## Front-end work

Alright, our API's running well, our database is secure, and we know how to handle login. Let's quickly go over how I built the front-end for this app.

### Essentials

We've already got a basic front-end app running that accepts Google login information. We'll now define another route (I'm using the `react-router-dom` package for this) and declare the real UI components of our app here. Following my [code](https://github.com/kanishk98/graphql-todo/blob/master/src/components/Main.js) might help for this section. 

I've used the `reactstrap` package for quickly designing common components like the input bar, list items, and relevant modals. 

We'll define the obvious `onClick` and `onSubmit` methods to get the text of our todo item in the state, but how do we communicate this data to our GraphQL API?

We'll add a new file `src/graphql.js`. We'll export constants that are wrapped in a backtick string, something like this:
```js
export const update_todos = `
  mutation($todoId: String!) {
    update_todos(where: { todoId: { _eq: $todoId }}, _set: { completed: true }) {
      affected_rows
    }
  }
```
The above constant accepts the `todoId` as an argument. We just need to handle the actual *sending* of the request now. 

There are two ways to do this:
1. Using a GraphQL client library like Apollo (recommended for larger projects)
2. Writing a simple utility `.js` file to handle requests (recommended for learning more about the architecture behind-the-scenes).

As you may have guessed, I went with 2. And it turns out that Hasura helps us with that too - the same [page](https://github.com/hasura/graphql-engine/tree/master/community/boilerplates/auth-webhooks/firebase-cloud-functions) which we used while setting up our auth webhook details how to write such a file. So without adding any unnecessarily heavy dependencies to our project, we can just use this system.

I modified the file as `AxiosUtility.js` in my repository, changing the main API code to the following:
```js
export const postAxios = async (queryString, variables) => {
  const idToken = await getIdToken();

  const axios = axiosBase.create({
    baseURL: Constants.hasuraUrl,
    headers: {
      'Content-Type': 'application/json',
      Authorization: 'Bearer ' + idToken
    },
    responseType: 'json',
    method: 'post'
  });
  console.log(variables);
  return await axios({
    data: {
      query: queryString,
      variables: variables
    }
  }).catch(({ response: r }) => console.log(r));
};
```

As you can see, it accepts query variables also. 

Having written mutation and query operations, we can quickly implement adding users, adding todos, and retrieving todos for a given user by calling the `postAxios()` method above. 
Once we're done with that, we'll have to test our app. Navigate to the root directory of the React project and run `$ npm start` (or `$ yarn run`, whichever you prefer).

![Login test](https://rawgithubusercontent.com/kanishk98/graphql-todo/master/assets/login_test.png)

![Todos](https://rawgithubusercontent.com/kanishk98/graphql-todo/master/assets/todos.png)

As you may see in the above picture, some of the todo items have been struck out. That's what I'll come to next.

### Complete/incomplete tasks

We should probably allow users to mark a task as completed. I did this by rendering a simple modal every time someone clicks on a todo item, like this:

![Completion modal](https://rawgithubusercontent.com/kanishk98/graphql-todo/master/assets/completion_modal.png)

Clicking yes invokes the update operation I wrote above, and updates the task as completed. Completed tasks are struck off and moved to the bottom by a simple `this.setState()` method call.


## Possible improvements

A todo app should certainly also allow users to set a time when the task is due and be reminded accordingly. One idea that I have for implementing this is defining an event trigger on the Hasura engine that sends forward this date information to a notification handler service (maybe another Firebase Cloud Function?) that delivers the notification back to the webpage. Since this use case makes more sense for a mobile app than a web app, I haven't written it yet. Feel free to contribute with something similar though!

---

That marks the end of this tutorial. If you just want to try what I've built before getting your hands dirty, feel free to clone this project and run an `$ npm install && npm start` to play around. (You'll have to deal with access keys, of course).