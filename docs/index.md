# Building a to-do web app with Hasura GraphQL engine and React.js

If you've been following the tech world lately, you'll know that GraphQL is a cool new query language for APIs. It's got a lot of features that should make it an easy choice for anyone working on an API: the importance given to <i>what</i> rather than how, the ability to batch multiple requests easily, and the freedom of the client to define whatever data it wants without having to create a new endpoint.

However, GraphQL is not without its problems. Some of them are:

  - Difficulty in setting up a GraphQL server
  - Defining resolvers for each query/mutation/subscription
  - Connecting resolvers to the underlying database

Speaking from personal experience, that last one is definitely a nightmare. 

That's where Hasura's GraphQL Engine comes in. It provides an easy kickstart to GraphQL development by giving the developer access to Heroku deployment (or Docker container) for a GraphQL server that can perform queries on a connected PostgreSQL database. All we have to do is define our good old table schema and the GraphQL SDL is generated for us (as are the templates for common queries, mutations, and subscriptions). If you know Prisma, Hasura's engine will sound familiar, with one key difference - Prisma is an additional database server that interfaces the GraphQL API with the underlying database. You still need to write resolvers that handle queries made to a GraphQL server you write, and you have to define your schema in GraphQL. Hasura allows your front-end to call the GraphQL API directly, just by using a relational Postgres schema you define. 

With that context, let's get started with building the app. 

> To follow along in this tutorial, you'll need a computer with git, React.js and the Chrome web browser. The latter is useful for debugging React applications.

## Initialising the project

I'll be using the `create-react-app` package to initialise a starter React.js project.

```sh
$ npm install -g create-react-app
$ create-react-app graphql-todo
```

Next, I'll log on to Hasura's [website](https://hasura.io) and create a new deployment on Heroku. You can either click [here](https://heroku.com/deploy?template=https://github.com/hasura/graphql-engine-heroku) or go to [this](https://docs.hasura.io/1.0/graphql/manual/getting-started/heroku-simple.html#deploy-to-heroku) page and click on the deploy button if the former doesn't work. 

This'll lead you to a setup of a basic project (once you've logged in to Heroku, of course). This is what it looks like for me:

![Heroku setup](https://raw.githubusercontent.com/kanishk98/graphql-todo/master/assets/heroku_setup.png)

Click on 'Deploy app' and we can move on to the next step. 

## Defining our schema

If you've followed the above steps correctly, you should see a dashboard similar to this image below (ignore the headers in the screenshot for now, we'll come to that later)

![Hasura API explorer](https://raw.githubuser.content.com/kanishk98/graphql-todo/master/assets/api_explorer_dashboard.png)

Let's click on Data in the top row and define our schema.

Our todo app will require users to log in via a Google account. Therefore, we should keep track of the users logging in and link each user account to their todos. 
Therefore, we'll make two tables - `todos` and `users`. 

Let's first considers `users`. 

We definitely need to store `userId` (this'll be the Firebase-generated UID of each user). This'll be our relation's primary key. We also need to store their email, their name, and their profile picture. Not that we're using any of those for this basic version of our todo app, but we might want to add this information to personalise the app a little in the future. 

Next, let's move to `todos`. We'll be storing all todos generated by all users of our app in this table. 
We'll identify todos based on their `todoId` (a v4 [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier), our primary key) and we'll also need to associate each todo with a user. For that, we need to store our `userId` here as well. 
We'll obviously need `text` (non-nullable, non-unique) of the todo item. 
We should probably save the `date` of creation of the todo as well, to help us sort them.
We'll store a boolean data item - `completed` - with each todo that's pretty much self-explanatory.

One additional constraint we should definitely add here is defining the `userId` as a foreign key that references the `users` table. So we can edit the `userId` field once we're done defining the schema, and add a relationship. 

> Relationships are an interesting Hasura implementation of SQL constraints in GraphQL; they do a great job of ensuring data consistency just like constraints defined in SQL. 

Our relationship should look something like this:

![Foreign key relationship](https://raw.githubusercontent.com/kanishk98/graphql-todo/master/assets/foreign_key.png)

We're all set on the schema side! Let's check out our database using GraphQL queries. 

## Testing database as admin using GraphQL

Navigate to the GraphiQL tab and write your first query. (actually, it's a mutation, but let's not be that pedantic).

This is what it looks like:

```
mutation {
  insert_users(objects: [{
    userId: "random_uid",
    name: "Kanishk Kakar",
    profilePic: "very_handsome_picture",
    email: "random@email.com"
  }]) {
    affected_rows
  }
}
```

On executing the above, you should see something like this:

![Mutation example](https://raw.githubusercontent.com/kanishk98/graphql-todo/master/assets/mutation.png)

Let's test this using a query on the same relation:

![Query example](https://raw.githubusercontent.com/kanishk98/graphql-todo/master/assets/query.png)

As you can see, we (the front-end) define *which* user we want by means of the `{where: { _eq: 'whatever' }}` and then specify that we only want the user's email, not his profile picture or name. That's how GraphQL speeds up API development. 

However, we're executing these queries as the admin right now. We need to give certain privileges to the end users of our app as well. 

## Role-based permissions

Hasura's engine makes IAM really easy for us. Under data, choose a table and then click on the Permissions tab. 
Enter a new role (I'll just call mine user, and set permissions for different operations there).

[!Permissions](https://raw.githubusercontent.com/kanishk98/graphql-todo/master/assets/permissions.png)

This helps you define different user roles quickly, and was a personal delight for me. 

## Auth

To set up a login system, we'll use Firebase. Now, building the front-end system for that is trivial - we need to log on to the [Google Cloud Console](https://console.cloud.google.com), create a new project, and then make a new Firebase app on the [Firebase console](https://console.firebase.google.com).